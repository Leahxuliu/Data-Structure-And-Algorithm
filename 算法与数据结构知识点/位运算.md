# 1. 多进制

## 1.1 python自带函数

**十进制 -> 多进制**

* 十进制 -> 二进制
  * a = bin(x)
  * 结果a是string， x是int
  * 比如，bin(-8) = "-0b1000"
* 十进制 -> 八进制
  * a = oct(x)
  * 结果a是string， x是int
  * 比如，oct(3) = "0o3"
* 十进制 -> 十六进制
  * a = hex(x)
  * 结果a是string， x是int
  * 比如，hex(3) = "0x3"



**多进制 -> 十进制**

* int(string, base = 2/ 8/ ...)
* 注意，这里面的string可以有多进制符号“0b”等，也可以没有
* 比如， int(bin(2)[2:], 2) = 2



## 1.2 手动实现多进制转换

* 504

```python
# 注意负数！！！！！！

class Solution:
    def convertToBase7(self, num: int) -> str:
        if num == 0:
            return str(0)

        res = ''
        if num > 0: 
            flag = ''
        else:
            flag = '-' 
        
        num = abs(num)
        while num != 0:
            res = str(num % 7) + res
            num = num // 7
            
        return flag + res
```



# 2. 二进制位运算

* 符号占一位
* 32位计算机
  * [-2 ** 31, 2 ** 31 - 1]
  * [-1 << 31, 1 << 31 - 1]
  * [-2147483648, 2147483647]
* 64位计算机
  * [-2 ** 63, 2 ** 63 - 1]
  * [-1 << 63 ,1 << 63 - 1]



## 2.1 原码/反码/补码

* `原码`：True form

  * 符号位(0是正数，1是负数) + 数字

  *  比如如果是8位二进制:

    [+1]原 = 0000 0001

    [-1]原 = 1000 0001

* `反码`：One's complement

  * `正数的反码是其本身`

  * `负数的反码是在其原码的基础上, 符号位不变，其余各个位取反`

    [+1] = [00000001]原 = [00000001]反

    [-1] = [10000001]原 = [11111110]反

  * 为了计算

    * 计算十进制的表达式: 1-1=0

      > 1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原= [0000 0001]反 + [1111 1110]反 = [1111 1111]反 = [1000 0000]原 = -0

* `补码`：Two's complement

  * `正数的补码就是其本身`

  * `负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)`

    [+1] = [00000001]原 = [00000001]反 = [00000001]补

    [-1] = [10000001]原 = [11111110]反 = [11111111]补

  * 计算机的储存方式

  * 发现用反码计算减法, 结果的真值部分是正确的. 而唯一的问题其实就出现在"0"这个特殊的数值上. 虽然人们理解上+0和-0是一样的, 但是0带符号是没有任何意义的. 而且会有[0000 0000]原和[1000 0000]原两个编码表示0.

    于是补码的出现, 解决了0的符号以及两个编码的问题:

    > 1-1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 = [0000 0001]补 + [1111 1111]补 = [0000 0000]补=[0000 0000]原

  * 这样0用[0000 0000]表示, 而以前出现问题的-0则不存在了.而且可以用[1000 0000]表示-128:

    > (-1) + (-127) = [1000 0001]原 + [1111 1111]原 = [1111 1111]补 + [1000 0001]补 = [1000 0000]补



## 2.2 运算

* 位运算的优先级比较低，低于加减乘除，高于赋值，所以要及时打上括号！！！



### 2.2.1 << 左移

* `n << k`
  * n是要移的数，k是步数
  * n向左移动k位，也就是2: 000010 -> 010000
  * k必须是非负值
  * 数学意义，左移相当于*2
    * a<<b 相当于`a * (2 ** b)`
    * 2 << 3 --> 2 * 2**3
  * 注意边界

### 2.2.2 >> 右移

* `n >> k`
  * n是要移的数，k是步数
  * n向右移动k位
  * k必须是非负值
  * 数学意义，左移相当于除以2
    * a>>b 相当于`a // (2 ** b)`
    * 2 >> 3 --> 2 // 2**3 = 0
  * 应用
    * mid = l + (r - l) // 2 可以写成 mid = l + (r - l) >> 1
    * 取符号位判断正负（例如32位）
      * a >> 31 = 0 则整数
      * a >> 31 = -1 则负数 （-1//7 = -1）

### 2.2.3 & 与

* 一样是1，不一样是0
  * 1 & 1 = 1
  * 1 & 0 = 0
  * 0 & 0 = 0
  * 101 & 010 = 000
* 应用
  * 把第n位设0
    * &(n个0)
    * 。。。
  * 保留n位原值
    * 取最后一位：a & 1
    * 取第n位：a >> n - 1 & 1  (切记是n-1)
  * 判断某一位是0还是1， &1
    * 若1，则1
    * 若0，则0
  * 消掉n最后一位有效的1: n & n - 1



### 2.2.4 ｜ 或

* 只要有一个1，其结果就是1
  * 1 ｜ 1 = 1
  * 1 ｜ 0 = 1
  * 0 ｜ 0 = 0

* 应用
  * 





### 2.2.5 ^ 异或（XOR）

* 相同是0， 不相同是1
  * 1 ^ 1 = 0
  * 1 ^  0 = 1
  * 0 ^  0 = 0
* 结合律：x ^ y ^ z = (x ^ y) ^ z = x ^ (y ^ z)  
* 交换律：x ^ y = y ^ x
* 对于任何数都成立：x ^ x = 0, x ^ 0 = x
* 自反性：x ^ y ^ y = x ^ 0 = x
* 若x ^ y = z， 则x ^ z = y, y ^ z = x (5649. Decode XORed Array)

* 应用
  * ....



### 2.2.6 ～取反

* 0变1，1变0
  * 对数字的**补码**形式进行取反
  * 不是对数字的二进制进行取反
* 数学意义：
  * ～n = -n -1
  * 15 = 001111 --> ~15 = 111000 = -16



### 2.2.7 运算优先级

* 取反 > 乘除 > 加减 > 左移/右移 > 并 > 或/异或 > 比较大小
* 分不清楚就及时打括号



# 3. LC题

## 3.1 Gray Code

格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。

格雷编码序列必须以 0 开头。

<img src="/Users/leah/Dropbox/Leetcode/CS61B/CS61B_Xu/notebook/graph/截屏2021-01-06 上午9.17.50.png" alt="截屏2021-01-06 上午9.17.50" style="zoom:67%;" />

* 比如求n=3 (n=2的结果已知 )
  * 对(n-1)的数组，前面都加0 --> G(n) （本质数都不发生改变）
  * 对G(n)的数组，从后往前遍历，把第一个位的0变成1 --> R(n)
    * 也就是+2**n
  * G(n) + R(n)就是答案

```python
class Solution:
    def grayCode(self, n: int) -> List[int]:
        res, head = [0], 1
        for i in range(n):
            for j in range(len(res) - 1, -1, -1):
                res.append(head + res[j])
            head <<= 1
        return res
```

